<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src&#x2F;common&#x2F;informe.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>informe.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../common/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
</pre><pre class="rust">
<span class="doccomment">//! Informe</span>
<span class="doccomment">//! ---</span>
<span class="doccomment">//! [Leer en PDF](http://...)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! [Leer en HTML](http://...)</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Parte A</span>
<span class="doccomment">//! La resolución de la primera parte del Trabajo Práctico se encuentra en la carpeta `src/threads` y se podrá ejecutar con `cargo run --bin threads`.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Enunciado</span>
<span class="doccomment">//! *Implementar la aplicación utilizando las herramientas de concurrencia de la biblioteca standard de Rust vistas en clase: Mutex, RwLock, Semáforos (del crate std-semaphore), Channels, Barriers y Condvars.*</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Resolución</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ### Estructuras</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Flight Reservation</span>
<span class="doccomment">//! En primer lugar, se crea una estructura que representa una reserva de vuelo. A cada vuelo ingresado por consola, se le asignara un ID para ayudarnos a identificarlo.</span>
<span class="doccomment">//! Ademas, la estructura cuenta con la información necesaria para que el vuelo se pueda reservar con las configuraciones pedidas. Se almacenara su origen y destino, la aerolinea correspondiente a la que se le realizara el request y si el pedido incluye o no la reserva de hotel.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! pub struct FlightReservation {</span>
<span class="doccomment">//!    pub id: i32,</span>
<span class="doccomment">//!    pub origin: String,</span>
<span class="doccomment">//!    pub destination: String,</span>
<span class="doccomment">//!    pub airline: String,</span>
<span class="doccomment">//!    pub hotel: bool,</span>
<span class="doccomment">//!}</span>
<span class="doccomment">//!```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Statistics</span>
<span class="doccomment">//! Estructura que contiene las estadísticas de la aplicación. Por un lado, contamos con un acumulador de tiempo para poder estimar el tiempo promedio que toma una reserva desde que ingresa el pedido hasta que es finalmente aceptada. Por otro lado, un `HashMap` en donde se iran guardando todas las rutas (origen - destino) realizadas para poder llevar una estadística de las rutas mas frecuentes.</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! pub struct Statistics {</span>
<span class="doccomment">//!    sum_time: Arc&lt;RwLock&lt;i64&gt;&gt;,</span>
<span class="doccomment">//!    destinations: Arc&lt;RwLock&lt;HashMap&lt;String, i64&gt;&gt;&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Como se puede ver en la estructura, ambas estructuras son `Arc` para que se puedan usar en varios threads. Ademas, se usa `RwLock` para proveer seguridad a la hora de leer y escribir en las mismas. Esto se debe a que todos los pedidos que ingresan al sistema van a estar intentando acceder a los recursos de estadisticas, es por eso que es necesario el uso de un mecanismo de sincronismo para que no haya conflictos. `RwLock` nos va a permitir tener un escritor (lock exlusivo) o varios lectores a la vez(lock compartido).</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### AppState</span>
<span class="doccomment">//! Esta última estructura se trata del estado compartido que se compartirá en cada thread que escuche nuevas solicitudes. </span>
<span class="doccomment">//! La estrcutura contiene:</span>
<span class="doccomment">//! - Las aereolinas del tipo `Airlines`, que se trata de un mapa de todas las Aereolineas con webservice disponibles en nuestro sistema. `Airlines` es un `HashMap` de tipo `&lt;String, Arc&lt;Semaphore&gt;&gt;`, en donde la clave es el nombre de la aereolinea. Y el valor es lo que simula ser el webservice, en este caso, un `Semaphore` que nos permitirá controlar la cantidad de solicitudes que se pueden realizar a cada webservice, teniendo en cuenta que cada aereolinea cuenta con un `rate_limit`. </span>
<span class="doccomment">//!  Este mapa se popula a partir de un archivo `src/configs/airlines.txt`, el cual indica todos los nombres de las aereolineas junto a los N pedidos que puede responder de forma concurrente.</span>
<span class="doccomment">//! - La estructura de estadísticas `Statistics` para poder acceder y agregar estadísticas a la aplicación.</span>
<span class="doccomment">//! - El `logger_sender` para poder enviar mensajes al canal de logs desde cada thread. Para lograr este pasaje de mensajes al canal de logs, se usa un `Sender` que permite enviar mensajes al otro lado del canal (multiples consumidores y un solo productor).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! struct AppState {</span>
<span class="doccomment">//!     airlines: Airlines,</span>
<span class="doccomment">//!     statistics: Statistics,</span>
<span class="doccomment">//!     logger_sender: Sender&lt;LoggerMsg&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ### Implementación</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Inicialización</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! El main esta compuesto por una serie de threads con diferentes tareas: </span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - `logger`: El primer thread que se abre es el logger, que se encarga de escribir tanto por consola como en el archivo de loggueo, los mensajes que se van a ir recibiendo. Como se explico previamente, esto esta implementado con un `mpsc::channel` con el objetivo que desde cualquier lugar de la aplicación se pueda enviar mensajes con el `Sender` y desde el thread `logger` los mensajes sean leidos por el `Receiver`.</span>
<span class="doccomment">//! - `http-server`: Se hace uso de Actix web para recibir requests reales por consola, por lo que este thread crea la App con el estado de la aplicación `AppState` y se queda a la espera de requests para resolverlos.</span>
<span class="doccomment">//! - `keyboard-loop`: Por último, por detras tenemos al keyboard que se encarga de recibir dos posibles comandos: &#39;S&#39;/&#39;STATS&#39; que nos permitirá mostrar las estadísticas de la aplicación, y &#39;Q&#39;/&#39;QUIT&#39; que nos permitirá salir de la aplicación.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Aplicación</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Una vez que ya tenemos todo el sistema inicializado, nuestro sistema ya esta listo para recibir nuevos requests. Si todos los parametros ingresados son correctos, se procede a realizar la reserva. Si no, se muestra un mensaje de error.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! La lógica de la aplicación se encuentra en el archivo `src/threads/alglobo.rs` . En primer lugar se abre un nuevo thread para poder ejecutar concurrentemente el request a la aereolinea por un lado y por el otro lado el request al hotel si el mismo lo requiere(en caso de que el pedido incluya el modo de paquete completo).</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! En el caso de que la reserva sea por paquete, el pedido se envia al webservice del hotel y como sus reservas nunca se rechazan, el tiempo que tarda en procesar la respuesta simplemente se simula con un sleep de un tiempo random.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! De forma simultanea, se envia el pedido a la aereolinea correspondiente. El tiempo que demora en realizar el request va a depender de la cantidad de request que soporta la aereolinea concurrentemente, ya que si la misma esta respondiendo la cantidad maxima de pedidos, el request de la aereolinea se va a bloquear y debera esperar a que un pedido anterior termine. Esto esta resuelto por el mismo semaforo que solo le va a permitir acceso a los pedidos si su contador interno es positivo, cada pedido que ingresa adquiere el semaforo decrementando en uno el contador, una vez que finaliza el pedido se incrementa el contador desbloqueando un hilo. </span>
<span class="doccomment">//! Ademas la aerolínea puede aceptar el pedido o recharzarlo (se simula con un random booleano). Si es rechazado, el sistema espera `retry_seconds` segundos para reintentar el pedido. La cantidad de segundos para reintentar es configurable via variable de entorno `RETRY_SECONDS`. Por ultimo va a depender del tiempo que tarda en procesar el request que tambien es simulado simplemente con un sleep de tiempo random.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! El resultado final de la reserva entonces necesitará que ambos pedidos (hotel y aerolinea) se completen en el caso de ser paquete o unicamente el pedido a la aereolinea. Es decir que no se puede agregar las estadisticas ni finalizar el request hasta que ambos threads hayan finalizado, y eso se resuelve a partir de monitores, esta herramienta nos brinda la posibilidad de esperar hasta que se cumpla una condición, en este caso si se reserva un paquete se debe esperar que ambos pedidos sean completados y sino solamente el request a la aereolinea.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Una vez que se completa el request a la aereolinea, se procede a agregar las estadísticas correspondientes, se suma el tiempo total que tardo en procesarse el pedido de principio a fin y se agrega la ruta solicitada(para agregar estas estadisticas, sera necesario obtener el lock para poder leer el estado actual de las estadisticas y agregar las nuevas).</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ![Threads](../../../../img/threads.jpg)</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! # Parte B</span>
<span class="doccomment">//! La resolución de la primera parte del Trabajo Práctico se encuentra en la carpeta `src/atix` y se podrá ejecutar con `cargo run --bin atix`.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Enunciado</span>
<span class="doccomment">//! *Implementar la aplicación basada en el modelo de Actores, utilizando el framework Actix.*</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Resolución</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ### Actores</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### StatActor</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! El actor `StatActor` se encarga de manejar las estadísticas de la aplicación. La estructura del actor cuenta con la acumulacion de los tiempos que toman los request, un `HashMap` con las rutas solicitadas y un `HashMap` con los IDs de los request junto con un contador para saber si finalizo su procesamiento.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! pub struct StatsActor {</span>
<span class="doccomment">//! sum_time: i64,</span>
<span class="doccomment">//! destinations: HashMap&lt;String, i64&gt;,</span>
<span class="doccomment">//! flights: HashMap&lt;i32, i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Este actor puede recibir un mensaje a la vez del tipo `Stat`. Al recibir este tipo de mensajes, si el request esta finalizado(es decir que si se trata de un paquete, finalizo tanto el pedido del hotel como el de la aereolinea), entonces se procede a sumar el tiempo de procesamiento al contador de tiempos totales y se agrega la ruta al `HashMap` de rutas frecuentes. Además imprimer por consola las estadisticas hasta el momento que incluyen la cantidad de vuelos, el tiempo total de procesamiento, el tiempo promedio de procesamiento y las 3 rutas más frecuentes.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Por otro lado, puede recibir un mensaje del tipo `FinishMessage` que indica que ya no quedan requests por procesar, por lo que se procede a finalizar la aplicación.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Airline</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El actor `Airline` simula el webservice de la aereolinea. La estructura unicamente cuenta con la referencia al `StatActor` para poder enviarle los mensajes de estadisticas una vez que termina de procesar el request.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! A diferencia de `StatActor`, este actor se implementa con un `SyncContext` y esto se debe a que este actor se ejecuta en un `SyncArbitrer` que permite ejecutar `rate_limit` actores simultaneamente. Por lo que, por cada aereolinea, se tiene un `SyncArbitrer` que permite ejecutar N `Airline` simultaneamente acorde a su `rate_limit` establecido en el archivo `src/config/ariline.txt`.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Este actor recibe unicamente mensajes del tipo `InfoFlight` y el actor va a simular el procesamiento del request, es decir, va a simular el tiempo que tarda en procesar el request. Este tiempo estare compuesto de la misma manera que esta explicado en la parte A del Trabajo Práctico, es decir que el tiempo va a depender de: cuantos request se pueden procesar simultaneamente, el tiempo que tarda en procesar un request(sleep con duración random) y como puede rechazar los pedidos, se esperaran `retry_seconds` segundos si se rechaza para reintentar el pedido, hasta que se acepte.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Una vez que completa el request, realiza un `try_send` al `StatActor` para enviarle el mensaje de estadisticas correspondiente con el tiempo que tardo en procesar el pedido.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Hotel</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! El actor `Hotel` simula el webservice del hotel. Al igual que la aereolinea, la estructura unicamente cuenta con la referencia al `StatActor` para poder enviarle los mensajes de estadisticas una vez que termina de procesar el request.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! El Hotel también es ejecutado en un `SyncArbitrer` que permite ejecutar todos los request en simultaneo.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Este actor recibe mensajes del tipo `InfoFlight` y a los mismos responde simulando el procesamiento del request, es decir, va a simular el tiempo que tarda en procesar el request. Pasado el tiempo de procesamiento (sleep de duracion random), se enviara un mensaje al `StatActor` para avisarle que se completo el request y se le mandaran las estadisticas correspondientes con el tiempo que tardo en procesar el pedido.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ### Mensajes</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### InfoFlight</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Mensaje que se envía a los actores `Airline` y `Hotel` para indicar que se recibio un request de vuelo. Esta compuesto por la información del vuelo y el tiempo que comenzo a procesarse el request. La respuesta esperada para este tipo de mensajes es vacia.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! pub struct InfoFlight {</span>
<span class="doccomment">//! pub flight_reservation: FlightReservation,</span>
<span class="doccomment">//! pub start_time: std::time::Instant,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! #### Stat</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Mensaje que se envía al actor `StatsActor` para indicar que finalizo de procesarse el request de vuelo. Esta compuesto por el tiempo de procesamiento de un request y `FlightReservation` para conocer la informacion del vuelo. La respuesta esperada para este tipo de mensajes es vacia.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! pub struct Stat {</span>
<span class="doccomment">//! pub elapsed_time: u128,</span>
<span class="doccomment">//! pub flight_reservation: FlightReservation,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Testing</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - Para la parte A, se realizan pruebas de volumen gracias a el uso de Atix web, en donde con mayor facilidad se logro enviar muchos pedidos en simultaneo para validar el funcionamiento del programa.</span>
<span class="doccomment">//! - Se realizan pruebas automatizadas en donde se realizan varias pruebas de una vez, para validar el funcionamiento del programa, implementando nuevamente aquellos métodos que no son deterministicos.</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! ## Post Mortem</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! - try_send()</span>
<span class="doccomment">//! - condvar por barrieres</span>
<span class="doccomment">//! - loom</span>
<span class="doccomment">//! - atixweb en actroes</span>
<span class="doccomment">//! - exxplicar porque no usamos stdout para el log (las stats te lo cagan)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Ideas de Todos:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Hablar de correctitud, estado mutable compartido, por que no es fork join, barriers y semaforos</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Detalle de resolución de la lista de tareas anterior.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! </span>
<span class="doccomment">//! Clavar un par de screenshots de htop</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Diagramas de entidades realizados (structs y demás).</span>
</pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="common" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>