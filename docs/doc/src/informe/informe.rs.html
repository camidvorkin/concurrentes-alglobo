<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src&#x2F;informe.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>informe.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../informe/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
</pre><pre class="rust">
<span class="doccomment">//! Informe</span>
<span class="doccomment">//! ---</span>
<span class="doccomment">//! Este informe puede ser leido tanto en [PDF](https://camidvorkin.github.io/concurrentes-alglobo/informe.pdf) (gracias a `pandoc`) como en [HTML](https://camidvorkin.github.io/concurrentes-alglobo/doc/informe/index.html) (gracias a `rustdoc`)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Para documentación especifica del código fuente que excede a este informe se puede consultar la [documentación de la aplicación](https://camidvorkin.github.io/concurrentes-alglobo/doc/actix/index.html) (en inglés).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Trabajo Práctico</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Este trabajo práctico se forma por dos distintas implementaciones de un sistema de reservas de vuelos a procesar de manera concurrente:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La primera parte consiste de un servidor HTTP que responde reservas de vuelos, y para cada una levanta distintos hilos.</span>
<span class="doccomment">//!   - El motor del servidor es [actix-web](https://actix.rs/)</span>
<span class="doccomment">//!   - Su código fuente se puede encontrar en [src/threads](https://camidvorkin.github.io/concurrentes-alglobo/doc/threads/index.html)</span>
<span class="doccomment">//!   - El servidor se puede levantar con `cargo run --bin threads` y un ejemplo de un pedido de reserva es `curl -i -d &#39;{&quot;origin&quot;:&quot;EZE&quot;, &quot;destination&quot;:&quot;JFK&quot;, &quot;airline&quot;:&quot;AA&quot;, &quot;hotel&quot;:true}&#39; -H &quot;Content-Type: application/json&quot; -X POST http://localhost:8080/`</span>
<span class="doccomment">//!   - Esta implementación tiene pruebas que pueden ser ejecutadas con `cargo test --bin threads` y una prueba de carga para el servidor se puede ejecutar con `./apache-ab-stresstest.sh` que utiliza la herramienta [Apache ab](http://httpd.apache.org/docs/current/programs/ab.html)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La segunda parte consiste en leer un archivo CSV con las distintas reservas de vuelo, y para estas ejecutar un sistema de actores que irán procesandolos.</span>
<span class="doccomment">//!   - El framework de actores utilizados es [actix](https://github.com/actix/actix)</span>
<span class="doccomment">//!   - Su código fuente se puede encontrar en [src/actix](https://camidvorkin.github.io/concurrentes-alglobo/doc/actix/index.html)</span>
<span class="doccomment">//!   - El programa se puede ejecutar con `cargo run --bin actix` que lee las reservas de un archivo CSV de prueba, o ejecutar con `cargo run --bin actix &lt;archivo_de_vuelos&gt;` para proporcionar un CSV propio. Una fila de ejemplo del CSV es `EZE,JFK,AA,true`</span>
<span class="doccomment">//!   - Esta implementación tiene pruebas que pueden ser ejecutadas con `cargo test --bin actix`</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Dentro de [src/common](https://camidvorkin.github.io/concurrentes-alglobo/doc/common/index.html) se encuentran las funciones comunes a ambas implementaciones.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Primera implementación -- Hilos</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! *Implementar la aplicación utilizando las herramientas de concurrencia de la biblioteca standard de Rust vistas en clase: Mutex, RwLock, Semáforos (del crate std-semaphore), Channels, Barriers y Condvars.*</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La primera implementación del modelo es a base de hilos y de un servidor HTTP que esta constantemente escuchando nuevas reservas.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Los hilos activos al estar el sistema escuchando por nuevos requests, y los hilos activos al estar procesando un solo request se pueden ver en las siguientes dos capturas del programa `htop`:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/htop-threads.png)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Hilos y funcionamiento</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La función `main` en `src/threads/main.rs` levanta los distintos hilos y el servidor en sí.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Lo primero que hace es levantar el hilo `logger` el cual se encargará de escribir tanto por consola como en el archivo de log los mensajes que se van a ir recibiendo. Este hilo no es más que un típico problema productor-consumidor: contiene un canal (`mpsc`) que está constantemente escuchando mensajes que le puede mandar el sistema, y estos se vierten sobre un archivo de log. La implementación de canal y mensajes es para evitar que dos hilos accedan a la vez al recurso compartido (el archivo en sí). Este loop infinito se termina cuando el logger recibe que debe registrar un mensaje de finalización.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Se procesa un archivo CSV de aerolineas (configurable en el directorio `src/configs`) que contiene los nombres de las aerolineas y la cantidad de pedidos simultaneos que pueden tomar.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Se inicializa la entidad de estadisticas, que va a ser accedida por cada pedido de vuelo, y por ende debe ser bien protegida frente a problemas de sincronización de hilos.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Después de esto se levanta el thread `http-server` que levantara al servidor de actix-web. Por detrás, actix-web levanta el hilo `actix-server ac` y los N hilos `actix-rt:worker` que escuchan nuevos requests. Como explica [en la documentación](https://actix.rs/docs/server/#multi-threading), esta cantidad de trabajadores puede ser configurada, y es por defecto la cantidad de CPUs en el sistema donde se ejecuta. Estos hilos no son manejados por nosotros, y su finalización se logra llamando a [actix_web::Server::stop](https://docs.rs/actix-web/3.0.2/actix_web/dev/struct.Server.html#method.stop), el cual va a hacer un *graceful shutdown* del servidor (de estar procesando algo actualmente, esperará a que el pedido sea finalizado). Este servidor se crea con un `AppState` que es compartido por todos los hilos creados por actix-web y que contiene las distintas aerolineas, la entidad de estadísticas de la aplicación y una referencia al `mpsc` del logger. Tal como se explica [en la documentación](https://actix.rs/docs/application/#shared-mutable-state) de actix-web, el estado debe estar seguramente compartido para que los hilos no entren en ningun tipo de problema de sincronía al acceder a este.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El hilo principal pasa a estar escuchando activamente por eventos del teclado, para poder imprimir las estadísticas de los vuelos procesados (al recibir la tecla `S`) o para saber si comenzar el *graceful shutdown* (al recibir la tecla `Q`)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Reserva de vuelos</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una vez que ya tenemos todo el sistema inicializado, lo más importante es ver que sucede al recibir un request.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El servidor tiene un *handler* de `POST` a la ruta `/` donde se reciben vuelos en forma de archivos json que especifican el vuelo a reservar:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```json</span>
<span class="doccomment">//!  {</span>
<span class="doccomment">//!   &quot;origin&quot;: &quot;EZE&quot;, // Aeropuerto de origen</span>
<span class="doccomment">//!   &quot;destination&quot;: &quot;JFK&quot;, // Aeropuerto de destino</span>
<span class="doccomment">//!   &quot;airline&quot;: &quot;AA&quot;, // Aerolinea, que debe ser una de las aerolineas disponibles en el programa</span>
<span class="doccomment">//!   &quot;hotel&quot;: true // Indica si el pedido debe pasar por el servidor del hotel o no</span>
<span class="doccomment">//!  }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Luego de chequear que el aeropuerto sea valido, este handler llama a `alglobo::reserve`, la función con la lógica principal del programa (encontrada en `src/threads/alglobo.rs`). Lo que logra esta función es concurrentemente ejecutar ambos requests (al servidor de la aerolinea y al servidor del hotel) y esperar a que ambos terminen, y luego, devolver el resultado de ambos. Para esto, se levantan dos hilos (uno con el nombre de la aerolinea, como en nuestro ejemplo la aerolinea `AA`, y otro simplemente llamado `hotel`) que simulan ambos pedidos a los servers.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El servidor del hotel es único para todo el programa, y no tiene límites. Todos los pedidos pueden ir directamente a él y esperar la respuesta. La simulación es siempre exitosa, y el pedido solo consta de esperar un tiempo al azar de no más de un segundo y medio. Esta espera se simula con `std::thread::sleep()`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El servidor de la aerolinea solo puede atender N pedidos de vuelos simultaneamente. Esto se logra con un semáforo (`std_semaphore::Semaphore`) inicializado con su contador interno en la cantidad de pedidos configurados en el archivo CSV de aerolineas. Cada pedido que ingresa adquiere el semáforo (decrementando en uno el contador), una vez que finaliza el pedido se incrementa el contador nuevamente, para dar lugar al próximo hilo. Cada hilo solo puede tomar el semaforo si el contador interno es positivo.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La simulación de la aerolínea puede ser exitosa o rechazar el pedido. Si este rechazado, el sistema espera N segundos para reintentarlo. La cantidad de segundos para reintentar es configurable vía la variable de entorno `RETRY_SECONDS`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El resultado final de la reserva entonces necesitará que ambos pedidos (hotel y aerolínea) hayan finalizado exitosamente. Una vez terminado, la función se encargara de agregar las estadísticas del vuelo. No se puede agregar las estadísticas ni finalizar el request si ambos threads no finalizaro, y eso se resuelve a partir de monitores. Esta herramienta nos brinda la posibilidad de esperar hasta que se cumpla una condición, y así logra la sincronización entre ambos requests.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una vez que se completa el pedido, se procede a agregar las estadísticas correspondientes. Esto incluye agregar el tiempo de procesamiento en las simulaciones, y la ruta solicitada, para luego poder reportar estas distintas estadísticas operacionales y de negocio. Estas estadisticas están detras de un lock de escritura y lectura, para evitar que haya problemas de sincronización entre distintos pedidos.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/threads.jpg)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Estructuras</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! CLAVAR ACA UN DIAGRAMA</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### Flight Reservation</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! En primer lugar, se crea una estructura que representa una reserva de cada vuelo recibido en el `POST` del server. A cada vuelo ingresado se le asigna un ID para identificarlo.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Además, la estructura cuenta con la información necesaria para que el vuelo se pueda reservar con las configuraciones pedidas. Se almacenará su origen y destino, la aerolínea correspondiente a la que se le realizará el requisito y si el pedido incluye o no la reserva de hotel.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! pub struct FlightReservation {</span>
<span class="doccomment">//!    pub id: i32,</span>
<span class="doccomment">//!    pub origin: String,</span>
<span class="doccomment">//!    pub destination: String,</span>
<span class="doccomment">//!    pub airline: String,</span>
<span class="doccomment">//!    pub hotel: bool,</span>
<span class="doccomment">//!}</span>
<span class="doccomment">//!```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### Statistics</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Estructura que contiene las estadísticas de la aplicación. Por un lado, contamos con un acumulador de tiempo para poder estimar el tiempo promedio que toma una reserva desde que ingresa el pedido hasta que es finalmente aceptada. Por otro lado, un `HashMap` en donde se irán guardando todas las rutas (origen - destino) realizadas para poder llevar una estadística de las rutas más frecuentes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! pub struct Statistics {</span>
<span class="doccomment">//!    sum_time: Arc&lt;RwLock&lt;i64&gt;&gt;,</span>
<span class="doccomment">//!    destinations: Arc&lt;RwLock&lt;HashMap&lt;String, i64&gt;&gt;&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Como se puede ver en la estructura, ambas campos son `Arc` para que se puedan usar en varios threads. Además, se usa `RwLock` para proveer seguridad a la hora de leer y escribir en las mismas. Esto se debe a que todos los pedidos que ingresan al sistema van a estar intentando acceder a los recursos de estadísticas, es por eso que es necesario el uso de un mecanismo de sincronismo para que no haya conflictos. `RwLock` nos va a permitir tener un escritor (lock exclusivo) o varios lectores a la vez(lock compartido).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### AppState</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Esta última estructura se trata del estado compartido que se compartirá en cada thread que escuche nuevas solicitudes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La estructura contiene:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Las aerolíneas del tipo `Airlines`, que se trata de un mapa de todas las Aerolíneas con webservice disponibles en nuestro sistema. `Airlines` es un `HashMap` de tipo `&lt;String, Arc&lt;Semaphore&gt;&gt;`, en donde la clave es el nombre de la aerolínea. Y el valor es lo que simula ser el webservice, en este caso, un `Semaphore` que nos permitirá controlar la cantidad de solicitudes que se pueden realizar a cada webservice, teniendo en cuenta que cada aerolínea cuenta con un `rate limit`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!  Este mapa se popula a partir de un archivo `src/configs/airlines.txt`, el cual indica todos los nombres de las aerolíneas junto a los N pedidos que puede responder de forma concurrente.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La estructura de estadísticas `Statistics` para poder acceder y agregar estadísticas a la aplicación.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El `logger_sender` para poder enviar mensajes al canal de logs desde cada thread. Para lograr este pasaje de mensajes al canal de logs, se usa un `Sender` que permite enviar mensajes al otro lado del canal (múltiples consumidores y un solo productor).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! struct AppState {</span>
<span class="doccomment">//!     airlines: Airlines,</span>
<span class="doccomment">//!     statistics: Statistics,</span>
<span class="doccomment">//!     logger_sender: Sender&lt;LoggerMsg&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Segunda implementación -- Actores</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! *Implementar la aplicación basada en el modelo de Actores, utilizando el framework Actix.*</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La segunda implementación del programa es a base del modelo de actores. Esto implica que remodelemos el programa original (buscando reutilizar la mayor cantidad de código posible) y deleguemos a `actix` la creación de hilos del programa, olvidandonos de `thread::spawn()` y `thread::join()`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! A diferencia de la primera implementación, en vez de tener un servidor HTTP, sencillamente tenemos un archivo CSV (que puede ser pasado por argumento de linea de comando, o por defecto se utiliza uno de prueba propio) que contiene una lista de los pedidos de vuelos a reservar. La idea principal del programa es crear un sistema de actores, iterar este archivo, y por cada uno levantar actores que se encargaran de la reserva</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! En esta captura de `htop` podemos ver que al correr el programa, en un ejemplo de 10 vuelos sin hotel, y con una aerolinea que tiene como límite 3 pedidos simultaneos, se levantan 3 hilos `actix` que se encargan de la reserva. Estos hilos son especificados al haber usado un `SyncArbiter`, que nos proporciona multi-threading en el framework.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/htop-actix.png)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Actores</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### StatActor</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El actor `StatActor` se encarga de manejar las estadísticas de la aplicación. La estructura del actor cuenta con la acumulacion de los tiempos que toman los request, un `HashMap` con las rutas solicitadas y un `HashMap` con los IDs de los request junto con un contador para saber si finalizó su procesamiento.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! pub struct StatsActor {</span>
<span class="doccomment">//!   sum_time: i64,</span>
<span class="doccomment">//!   destinations: HashMap&lt;String, i64&gt;,</span>
<span class="doccomment">//!   flights: HashMap&lt;i32, i32&gt;,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Este actor puede recibir un mensaje a la vez del tipo `Stat`. Al recibir este tipo de mensajes, si el request está finalizado(es decir que si se trata de un paquete, finalizó tanto el pedido del hotel como el de la aerolínea), entonces se procede a sumar el tiempo de procesamiento al contador de tiempos totales y se agrega la ruta al `HashMap` de rutas frecuentes. Además imprime por consola las estadísticas hasta el momento que incluyen la cantidad de vuelos, el tiempo total de procesamiento, el tiempo promedio de procesamiento y las 3 rutas más frecuentes.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Por otro lado, puede recibir un mensaje del tipo `FinishMessage` que indica que ya no quedan requests por procesar, por lo que se procede a finalizar la aplicación.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### Airline</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El actor `Airline` simula el webservice de la aerolínea. La estructura únicamente cuenta con la referencia al `StatActor` para poder enviarle los mensajes de estadísticas una vez que termina de procesar el requisito.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! A diferencia de `StatActor`, este actor se implementa con un `SyncContext` y esto se debe a que este actor se ejecuta en un `SyncArbitrer` que permite ejecutar `rate_limit` actores simultáneamente. Por lo que, por cada aerolínea, se tiene un `SyncArbitrer` que permite ejecutar N `Airline` simultáneamente acorde a su `rate_limit` establecido en el archivo `src/config/airline.txt`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Este actor recibe únicamente mensajes del tipo `InfoFlight` y el actor va a simular el procesamiento del request, es decir, va a simular el tiempo que tarda en procesar el request. Este tiempo estará compuesto de la misma manera que esta explicado en la parte A del Trabajo Práctico, es decir que el tiempo va a depender de: cuantos request se pueden procesar simultáneamente, el tiempo que tarda en procesar un request(sleep con duración random) y como puede rechazar los pedidos, se esperarán `retry_seconds` segundos si se rechaza para reintentar el pedido, hasta que se acepte.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una vez que completa el request, realiza un `try_send` al `StatActor` para enviarle el mensaje de estadísticas correspondiente con el tiempo que tardo en procesar el pedido.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### Hotel</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El actor `Hotel` simula el webservice del hotel. Al igual que la aerolínea, la estructura únicamente cuenta con la referencia al `StatActor` para poder enviarle los mensajes de estadísticas una vez que termina de procesar el request.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El Hotel también es ejecutado en un `SyncArbitrer` que permite ejecutar todos los request en simultáneo.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Este actor recibe mensajes del tipo `InfoFlight` y a los mismos responde simulando el procesamiento del request, es decir, va a simular el tiempo que tarda en procesar el request. Pasado el tiempo de procesamiento (sleep de duración random), se enviará un mensaje al `StatActor` para avisarle que se completó el request y se le mandaran las estadísticas correspondientes con el tiempo que tardo en procesar el pedido.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Mensajes</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### InfoFlight</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Mensaje que se envía a los actores `Airline` y `Hotel` para indicar que se recibe un request de vuelo. Está compuesto por la información del vuelo y el tiempo que comenzó a procesarse el request. La respuesta esperada para este tipo de mensajes es vacía.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! pub struct InfoFlight {</span>
<span class="doccomment">//!   pub flight_reservation: FlightReservation,</span>
<span class="doccomment">//!   pub start_time: std::time::Instant,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! #### Stat</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Mensaje que se envía al actor `StatsActor` para indicar que finalizó de procesarse el request de vuelo. Está compuesto por el tiempo de procesamiento de un request y `FlightReservation` para conocer la informacion del vuelo. La respuesta esperada para este tipo de mensajes es vacía.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```rust</span>
<span class="doccomment">//! pub struct Stat {</span>
<span class="doccomment">//!   pub elapsed_time: u128,</span>
<span class="doccomment">//!   pub flight_reservation: FlightReservation,</span>
<span class="doccomment">//! }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Testing</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Para la parte A, se realizan pruebas de volumen gracias a el uso de Actix web, en donde con mayor facilidad se logró enviar muchos pedidos en simultáneo para validar el funcionamiento del programa.</span>
<span class="doccomment">//! - Se realizan pruebas automatizadas en donde se realizan varias pruebas de una vez, para validar el funcionamiento del programa, implementando nuevamente aquellos métodos que no son determinísticos.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Post Mortem</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - try_send()</span>
<span class="doccomment">//! - condvar por barrieres</span>
<span class="doccomment">//! - loom</span>
<span class="doccomment">//! - atixweb en actroes</span>
<span class="doccomment">//! - exxplicar por qué no usamos stdout para el log (las stats te lo cagan)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Ideas de Todos:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Hablar de correctitud, estado mutable compartido, por que no es fork join, barriers y semáforos</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Clavar fotos y docuemntacion de actix web para hablar de los N workers que levanta para escuchar los gets</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Detalle de resolución de la lista de tareas anterior.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una explicación del diseño y de las decisiones tomadas para la implementación de la solución.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     Detalle de resolución de la lista de tareas anterior.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     Diagrama que refleje los threads, el flujo de comunicación entre ellos y los datos que intercambian.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!     Diagramas de entidades realizados (structs y demás).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Clavar un par de screenshots de htop</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Diagramas de entidades realizados (structs y demás).</span>

<span class="kw">fn</span> <span class="ident">main</span>() {}
</pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="informe" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>