<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src&#x2F;informe.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>informe.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../informe/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
</pre><pre class="rust">
<span class="doccomment">//! Informe</span>
<span class="doccomment">//! ---</span>
<span class="doccomment">//! Este informe puede ser leido tanto en [PDF](https://camidvorkin.github.io/concurrentes-alglobo/informe.pdf) (gracias a `pandoc`) como en [HTML](https://camidvorkin.github.io/concurrentes-alglobo/doc/informe/index.html) (gracias a `rustdoc`)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Para documentación especifica del código fuente que excede a este informe se puede consultar la [documentación de la aplicación](https://camidvorkin.github.io/concurrentes-alglobo/doc/actix/index.html) (en inglés).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Trabajo Práctico</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Este trabajo práctico se forma por dos distintas implementaciones de un sistema de reservas de vuelos a procesar de manera concurrente:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La primera parte consiste de un servidor HTTP que responde reservas de vuelos, y para cada una levanta distintos hilos.</span>
<span class="doccomment">//!   - El motor del servidor es [actix-web](https://actix.rs/)</span>
<span class="doccomment">//!   - Su código fuente se puede encontrar en [src/threads](https://camidvorkin.github.io/concurrentes-alglobo/doc/threads/index.html)</span>
<span class="doccomment">//!   - El servidor se puede levantar con `cargo run --bin threads` y un ejemplo de un pedido de reserva es `curl -i -d &#39;{&quot;origin&quot;:&quot;EZE&quot;, &quot;destination&quot;:&quot;JFK&quot;, &quot;airline&quot;:&quot;AA&quot;, &quot;hotel&quot;:true}&#39; -H &quot;Content-Type: application/json&quot; -X POST http://localhost:8080/`</span>
<span class="doccomment">//!   - Esta implementación tiene pruebas que pueden ser ejecutadas con `cargo test --bin threads` y una prueba de carga para el servidor se puede ejecutar con `./apache-ab-stresstest.sh` que utiliza la herramienta [Apache ab](http://httpd.apache.org/docs/current/programs/ab.html)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La segunda parte consiste en leer un archivo CSV con las distintas reservas de vuelo, y para estas ejecutar un sistema de actores que irán procesandolos.</span>
<span class="doccomment">//!   - El framework de actores utilizados es [actix](https://github.com/actix/actix)</span>
<span class="doccomment">//!   - Su código fuente se puede encontrar en [src/actix](https://camidvorkin.github.io/concurrentes-alglobo/doc/actix/index.html)</span>
<span class="doccomment">//!   - El programa se puede ejecutar con `cargo run --bin actix` que lee las reservas de un archivo CSV de prueba, o ejecutar con `cargo run --bin actix &lt;archivo_de_vuelos&gt;` para proporcionar un CSV propio. Una fila de ejemplo del CSV es `EZE,JFK,AA,true`</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Dentro de [src/common](https://camidvorkin.github.io/concurrentes-alglobo/doc/common/index.html) se encuentran las funciones comunes a ambas implementaciones.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Primera implementación -- Hilos</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! *Implementar la aplicación utilizando las herramientas de concurrencia de la biblioteca standard de Rust vistas en clase: Mutex, RwLock, Semáforos (del crate std-semaphore), Channels, Barriers y Condvars.*</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La primera implementación del modelo es a base de hilos y de un servidor HTTP que está constantemente escuchando nuevas reservas.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Los hilos activos al estar el sistema escuchando por nuevos requests, y los hilos activos al estar procesando un solo request se pueden ver en las siguientes dos capturas del programa `htop`:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/htop-threads.png)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Hilos y funcionamiento</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La función `main` en `src/threads/main.rs` levanta los distintos hilos y el servidor en sí.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Lo primero que hace es levantar el hilo `logger` el cual se encargará de escribir tanto por consola como en el archivo de log los mensajes que se van a ir recibiendo. Este hilo no es más que un típico problema productor-consumidor: contiene un canal (`mpsc`) que está constantemente escuchando mensajes que le puede mandar el sistema, y estos se vierten sobre un archivo de log. La implementación de canal y mensajes es para evitar que dos hilos accedan a la vez al recurso compartido (el archivo en sí). Este loop infinito se termina cuando el logger recibe que debe registrar un mensaje de finalización.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Se procesa un archivo CSV de aerolíneas (configurable en el directorio `src/configs`) que contiene los nombres de las aerolíneas y la cantidad de pedidos simultáneos que pueden tomar.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Se inicializa la entidad de estadísticas, que va a ser accedida por cada pedido de vuelo, y por ende debe ser bien protegida frente a problemas de sincronización de hilos.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Después de esto se levanta el thread `http-server` que levantara al servidor de actix-web. Por detrás, actix-web levanta el hilo `actix-server ac` y los N hilos `actix-rt:worker` que escuchan nuevos requests. Como explica [en la documentación](https://actix.rs/docs/server/#multi-threading), esta cantidad de trabajadores puede ser configurada, y es por defecto la cantidad de CPUs en el sistema donde se ejecuta. Estos hilos no son manejados por nosotros, y su finalización se logra llamando a [actix_web::Server::stop](https://docs.rs/actix-web/3.0.2/actix_web/dev/struct.Server.html#method.stop), el cual va a hacer un *graceful shutdown* del servidor (de estar procesando algo actualmente, esperará a que el pedido sea finalizado).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Este servidor se crea con un `AppState` que es compartido por todos los hilos creados por actix-web y que contiene las distintas aerolíneas, la entidad de estadísticas de la aplicación y una referencia al `mpsc` del logger. Tal como se explica [en la documentación](https://actix.rs/docs/application/#shared-mutable-state) de actix-web, el estado debe estar seguramente compartido para que los hilos no entren en ningún tipo de problema de sincronía al acceder a este.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El hilo principal pasa a estar escuchando activamente eventos del teclado, para poder imprimir las estadísticas de los vuelos procesados (al recibir la tecla `S`) o para saber si comenzar el *graceful shutdown* (al recibir la tecla `Q`)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Reserva de vuelos</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una vez que ya tenemos todo el sistema inicializado, lo más importante es ver que sucede al recibir un request.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El servidor tiene un *handler* de `POST` a la ruta `/` donde se reciben vuelos en forma de archivos json que especifican el vuelo a reservar:</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ```json</span>
<span class="doccomment">//!  {</span>
<span class="doccomment">//!   &quot;origin&quot;: &quot;EZE&quot;, // Aeropuerto de origen</span>
<span class="doccomment">//!   &quot;destination&quot;: &quot;JFK&quot;, // Aeropuerto de destino</span>
<span class="doccomment">//!   &quot;airline&quot;: &quot;AA&quot;, // Aerolínea, que debe ser una de las aerolíneas disponibles en el programa</span>
<span class="doccomment">//!   &quot;hotel&quot;: true // Indica si el pedido debe pasar por el servidor del hotel o no</span>
<span class="doccomment">//!  }</span>
<span class="doccomment">//! ```</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Luego de chequear que el aeropuerto sea válido, este handler llama a `alglobo::reserve`, la función con la lógica principal del programa (encontrada en `src/threads/alglobo.rs`). Lo que logra esta función es concurrentemente ejecutar ambos requests (al servidor de la aerolínea y al servidor del hotel) y esperar a que ambos terminen, y luego, devolver el resultado de ambos. En el caso de la reserva ser de solo vuelo, y no de hotel, no se manda este pedido adicional. Para esto, se levantan dos hilos (uno con el nombre de la aerolínea, como en nuestro ejemplo la aerolínea `AA`, y otro simplemente llamado `hotel`) que simulan ambos pedidos a los servers.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El servidor del hotel es único para todo el programa, y no tiene límites. Todos los pedidos pueden ir directamente a él y esperar la respuesta. La simulación es siempre exitosa, y el pedido solo consta de esperar un tiempo al azar de no más de un segundo y medio. Esta espera se simula con `std::thread::sleep()`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El servidor de la aerolínea solo puede atender N pedidos de vuelos simultáneamente. Esto se logra con un semáforo (`std_semaphore::Semaphore`) inicializado con su contador interno en la cantidad de pedidos que puede soportar esa aerolínea. Cada pedido que ingresa adquiere el semáforo (decrementando en uno el contador), una vez que finaliza el pedido se incrementa el contador nuevamente, para dar lugar al próximo hilo. Cada hilo solo puede tomar el semáforo si el contador interno es positivo.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La simulación de la aerolínea puede ser exitosa o fallida. Si el pedido es rechazado, el sistema espera N segundos para reintentarlo. Esta cantidad de segundos es configurable vía la variable de entorno `RETRY_SECONDS`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! El resultado final de la reserva entonces necesitará que ambos pedidos (hotel y aerolínea) hayan finalizado exitosamente. Una vez terminado, la función se encargará de agregar las estadísticas del vuelo. No se puede agregar las estadísticas ni finalizar el request si ambos threads no finalizaron, y eso se resuelve gracias a un monitor. Esta herramienta consiste de un mutex (`std::sync::Mutex`) y una **condition variable** (`std::sync::Condvar`) y nos brinda la posibilidad de esperar hasta que se cumpla una condición.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Una vez que se completa el pedido, se procede a agregar las estadísticas correspondientes. Esto incluye agregar el tiempo de procesamiento en las simulaciones, y la ruta solicitada, para luego poder reportar las estadísticas operacionales y las de negocio. Estas estadísticas están detrás de un lock de escritura y lectura, para evitar que haya problemas de sincronización entre distintos pedidos.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/threads.jpg)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Entidades</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/struct-threads.png)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La estructura principal del programa es la que representa pedidos de reservas de vuelos, **FlightReservation**. Esta estructura, en esta implementación, es des-serializable (con ayuda de [serde](https://serde.rs/)) para poder ser recibida como un JSON en el cuerpo del `POST`. Esta estructura entonces contiene los 4 atributos que requiere un vuelo (aeropuertos, aerolínea, y un indicador de hotel).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La entidad que se encarga de registrar las estadísticas, **Statistics** es una estructura a la que los distintos hilos de reservas irán accediendo, y por ende hay que proteger el acceso a sus atributos con un lock. Los únicos atributos que contiene son un acumulador de tiempo de reservas, para poder calcular el tiempo promedio de procesamiento, y un `HashMap` en donde se irán guardando todas las rutas (origen -&gt; destino). Esta estructura contiene métodos para poder calcular e imprimir estas estadísticas. Los métodos de impresión son ejecutados por el usuario al escribir en la consola una `S`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Las aerolíneas disponibles en el programa son simplemente un `HashMap` declarado con `pub type Airlines = HashMap&lt;String, Arc&lt;Semaphore&gt;&gt;` que se generan a partir del archivo CSV de configuración. Este `HashMap` tiene como clave el nombre de la aerolínea y como valor un semáforo, para lograr el **rate limit** de cada aerolínea.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El **logger** es simplemente una función para escribir al archivo de log de la aplicación, pero encapsulado en un canal `mpsc` para hacer que el acceso a este archivo sea ordenado.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Estas estructuras globales del sistema (las aerolíneas disponibles y las estadísticas), junto al recibidor del logger componen el estado mutable compartido que se reparte entre todos los hilos de los pedidos de vuelos, **AppState**.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ## Segunda implementación -- Actores</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! *Implementar la aplicación basada en el modelo de Actores, utilizando el framework Actix.*</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! La segunda implementación del programa es en base al modelo de actores. Esto implica que remodelemos el programa original (buscando reutilizar la mayor cantidad de código posible) y deleguemos a `actix` la creación de hilos del programa, olvidándonos de `thread::spawn()` y las herramientas tradicionales de concurrencia utilizadas en la implementación anterior, como los semáforos o los monitores.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! A diferencia de la primera implementación, en vez de tener un servidor HTTP, sencillamente tenemos un archivo CSV (que puede ser pasado por argumento de línea de comando, o por defecto se utiliza uno de prueba propio) que contiene una lista de los pedidos de vuelos a reservar. La idea principal del programa es crear un sistema de actores, iterar este archivo, y por cada uno levantar actores que se encargarán de la reserva.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! En esta captura de `htop` podemos ver que al correr el programa solo tenemos un hilo (el principal). Esto es porque ahora toda la concurrencia corre por parte de actix, y en vez de tener que sincronizar hilos entre sí, tengamos que ocuparnos de la sincronización entre actores. Levantar un actor es una operación mucho más liviana que levantar un hilo, haciendo que esta implementación sea menos intensiva en recursos que la anterior.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/htop-actix.png)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Funcionamiento y reservas</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Lo primero que sucede en la función `main` de `src/actix/main.rs` es leer el archivo de vuelos y convertirlo en un vector de la estructura `FlightReservation`, que se reutiliza de la implementación anterior.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Luego, se crea el actor que se encarga de manejar las estadísticas de esta implementación. Este actor es el análogo a la estructura **Statistics** anterior, pero reimplementado para el modelo actual. Esta entidad recibe en su inicialización la cantidad total de vuelos que se procesarán en el transcurso del programa, para poder apagar el sistema una vez que se haya registrado todo vuelo.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Lo siguiente que sucede es que se procesa el archivo CSV de aerolíneas, pero en vez de usar un `HashMap` de semáforos, ahora buscamos hacer un `HashMap` donde cada aerolínea tenga una tupla. En esta tupla tenemos dos valores, el rate limit, y la cantidad de vuelos actualmente siendo procesados (inicialmente 0). Con este diccionario, el actor `AirlineManager` se encargará de nunca enviar requests por sobre el *rate limit* al actor `Airline`, que es el actor único utilizado para todas las aerolíneas. El último actor creado es el del hotel, el cual no tiene ningún tipo de *rate limit*.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! Finalmente, esta función hará cada reserva solicitada, iterando los vuelos y levantando un actor para cada simulación de request (el request a la aerolínea irá a `AirlineManager` mientras que el del hotel irá a `Hotel`)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ### Actores y Mensajes</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! ![](../../img/actores-actix.png)</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - La estructura **FlightReservation** ahora se encapsula dentro **InfoFlight**, que es el mensaje que reciben los actores de las aerolíneas y del hotel.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - **InfoFlight** no es más que un vuelo y un poco de metadata acerca de este: el tiempo en el que empezó a ser procesado (para luego poder calcular el tiempo final de procesamiento) y un indicador de si este vuelo es nuevo o es simplemente un reintento de un vuelo fallido en alguno de los requests</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El actor **Hotel** va a ser el encargado de simular el procesamiento de los request que incluyan una reserva de hotel además de la del vuelo. Al igual que la primera implementación, el pedido consta de esperar un tiempo al azar de no más de un segundo y medio. Como el actor `Hotel` solo puede ejecutar un mensaje a la vez, para permitir la ejecución de otros pedidos en simultáneo se hace uso de los *sleeps de tasks*. Esto consiste de un llamado a  `actix::clock::sleep` dentro de un `Box::pin` que le permite al handler devolver un `ResponseActFuture`. Es decir que el actor `Hotel` no espera a que el sleep se complete para poder procesar el siguiente mensaje, pero una vez que finaliza, a través de un callback sí se encarga de finalizar con el procesamiento. Como la simulación es siempre exitosa, cuando finaliza el sleep, simplemente envía sus estadísticas al actor `Statistics`.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El actor **AirlineManager** cuenta con tres campos en su estructura: el `HashMap` para identificar la cantidad máxima de requests que tiene permitido procesar cada aerolínea y la cantidad que está procesando en ese momento; la dirección del actor `Airline` para poder enviarle los pedidos de reserva; un `HashMap` con una cola de vuelos que aún no se pueden procesar debido al *rate limit* de la aerolínea. Al contar con las colas de pedidos pendientes y el contador de pedidos ejecutándose, el manager resuelve las tareas de forma similar a un tradicional semáforo de concurrencia. El actor puede recibir dos tipos de mensaje:</span>
<span class="doccomment">//!   - Un mensaje `P` de tipo **NewRequest** en el que verifica si el *rate limit* de la aerolínea está disponible. Si lo está, lo procesa enviandoselo al actor **Airline**, y suma uno al contador. Si no esta disponible lo agrega a la cola de pedidos pendientes.</span>
<span class="doccomment">//!   - Un mensaje `V` de tipo **FinishRequest** que se encarga de restar en uno al contador y de verificar si hay algún pedido pendiente en la cola (y si lo hay, lo procesa).</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - Una vez que **AirlineManager** resuelve el *rate limit*, el **InfoFlight** se envía al actor **Airline**, el cual resolverá el vuelo de la misma manera que lo hacía **Hotel** (con un `sleep` dentro de `Box::pin`). La única diferencia entre estos dos actores es que el de la aerolínea puede fallar. En este caso, el actor re-intentará el vuelo, enviándose a sí mismo el **InfoFlight** recibido (con `actix::actor::AsyncContext::notify`), pero marcando que es un reintento, así haciendo la espera del servidor simulado más larga (los segundos de penalización previos al reintento, y los segundos de la simulación). Una vez exitoso el pedido, se le notifica a **AirlineManager** con **FinishRequest**, para quie haga lugar a siguientes pedidos.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//! - El último actor del programa es **StatsActor**, el cual recibe tanto de **Airline** como de **Hotel** los requests exitosos, encapsulados en el mensaje **Stat**. Al recibir un mensaje, el actor se fija si el vuelo tiene todos sus requests (uno si es solo un vuelo, o dos si es un vuelo y un hotel) en un `HashMap` interno, y si es así, registra en el `logger` al vuelo como finalizado. A diferencia de la implementación anterior, la manera de tener estadísticas periódicas es que cada N vuelos se impriman automáticamente (en vez de escuchar al teclado en un hilo aparte). Finalmente, si la cantidad total de vuelos procesados es igual a la cantidad recibida en la inicialización, el programa se dará por concluido y se apaga.</span>
<span class="doccomment">//!</span>
<span class="doccomment">//!</span>
<span class="kw">fn</span> <span class="ident">main</span>() {}
</pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="informe" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>